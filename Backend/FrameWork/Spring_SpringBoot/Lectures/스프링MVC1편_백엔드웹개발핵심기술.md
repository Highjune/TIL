## 스프링 MVC 1편 - 백엔드 웹 개발 핵심 기술
- [강의](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-1/dashboard) 들은 것 필기

# 웹 애플리케이션 이해
## 웹 서버, 웹 애플리케이션 서버
- 웹은 모든 것이 HTTP 기반으로 동작한다.
    - 클라이언트가 웹 브라우저에서 URL을 입력하면 인터넷을 통해서 서버에 접근.
    - 서버는 HTML을 만들어서 클라이언트에게 내려주면 웹 브라우저는 그 HTML을 받아서 보여준다.
    - 클라이언트 <--> 서버 상호간에 데이터를 주고받을 때 모든 것이 다 HTTP 로 움직인다.


- 웹 서버란?
    - HTTP 기반으로 동작
    - 정적 리소스 제공, 기타 부가기능 
    - 정적(파일) HTML, CSS, JS, 이미지, 영상
        - 특정 폴더에 파일들을 두면 -> `서버가 정적인 팡일들을 서빙`. 그래서 특정 사용자한테 다르게 보여주거나 할 수가 없다. (정적)
    - 예) NGINX, APACHE

- 웹 애플리케이션 서버(WAS - Web Application Server)
    - HTTP 기반으로 동작
    - 웹 서버 기능 포함 + (정적 리소스 제공 가능)
    - `(웹서버와 차이) 프로그램 코드를 실행`해서 애플리케이션 로직 수행 (프로그래밍이 가능)
        - 동적 HTML, HTTP API(JSON)
        - 서블릿, JSP, 스프링 MVC
        - 사람들에 따라서 다르게 보여줄 수 있다.(동적)
    - 예) 톰캣(Tomcat), Jetty, Undertow

- 웹 서버, 웹 애플리케이션 서버(WAS) 의 차이는?
    - `웹 서버는 정적 리소스(파일), WAS는 애플리케이션 로직`
    - 사실은 둘의 용어도 경계도 모호함
        - 웹 서버도 프로그램을 실행하는 기능을 포함하기도 함
        - 웹 애플리케이션 서버도 웹 서버의 기능을 제공함
    - 자바는 서블릿 컨테이너 기능을 제공하면 WAS
        - 서블릿 없이 자바코드를 실행하는 서버 프레임워크도 있긴 함
    - `WAS는 애플리케이션 코드를 실행하는데 더 특화`

- 웹 시스템 구성 - WAS, DB 으로 구성한다면?
    - WAS, DB 만으로 시스템 구성 가능
    - WAS는 정적 리소스, 애플리케이션 로직 모두 제공 가능
    - 그런데!
        - WAS가 너무 많은 역할을 담당, 서버 과부하 우려
        - 가장 비싼 애플리케이션 로직이 정적 리소스 때문에 수행이 어려울 수 있음
        - WAS 장애시 오류 화면도 노출 불가능(혼자서 다 수행하는데 자신이 뻗어버리면)
        - 그래서 작은 시스템은 괜찮은데 큰 시스템은 WAS 혼자서 좀 부담스럽다
- 그래서
    - 정적 리소스는 웹 서버가 처리(HTML, CSS, JS, 이미지)
    - 웹 서버는 애플리케이션 로직같은 동적인 처리가 필요하면 WAS에 요청을 위임
    - WAS는 중요한 애플리케이션 로직 처리 전담에 집중(장점)
    - 
- 웹 시스템 구성 - WEB, WAS, DB 으로 구성한다면?
    - 효율적인 리소스 관리 
        - 정적 리소스가 많이 사용되면 Web만 서버 증설(ex. 4배로)
        - 애플리케이션 리소스가 많이 사용되면 WAS 증설(ex. 8배로)
    - 정적 리소스만 제공하는 웹 서버는 잘 죽지 않음
        - 왜냐하면 정적인 파일들만 읽어서 그냥 보여주는 것이기 때문에
    - 애플리케이션 로직이 동작하는 WAS 서버는 잘 죽음
    - WAS, DB 장애시 WEB 서버가 오류 화면 제공 가능(Web Server에서 오류화면 HTML 보여줌)
    - 그런데 (화면 없이) 데이터를 뿌려주는 API 서버를 제공하게 되면 그때는 굳이 Web Server 가 별도로 필요하진 않다. 

## 서블릿
- 서블릿이 없을 경우(서버에서 처리해야 하는 업무) 웹 애플리케이션 서버 직접 구현해야 한다.
    - HTML Form 데이터 전송
        - 클라이언트가 POST 전송 - 저장
            - UI : username : kim , age : 20 . 전송
        ```
        <form action-"/save" method = "post">
            <input type = "text" name = "username" />
            <input type = "text" name = "age" />
            <button type = "submit">전송</button>
        </form>
        ```
        - 웹 브라우저가 생성한 요청 HTTP 메시지
        ```
        POST /save HTTP/1.1
        Host: localhost:8080
        Content-Type: application/x-www-form-urlencoded  // 폼 양식으로 보내면 이런 타입으로 형성

        username=kim&age=20  // 폼 양식으로 보내면 데이터가 이렇게 넘어간다.
        ```
        - 그런데!!! 응답 메시지를 바로 만들어내지 않고 (서블릿이 없다면)
            - 서버가 받은 위의 요청 메시지를 다 파싱해서 만들어야 한다.(위의 요청 메시지는 그냥 단순 다 텍스트임)
            - 즉 아래의 전체 단계에서 실질적으로는 `비즈니스 로직 실행`,`데이터베이스에 저장` 요청 2가지만 하면 되는데 전 후의 모든 전체 단계를 다 진행해서 HTTP 응답 메시지를 생성해야 한다.
            ```
            - 서버 TCP/IP 연결 대기, 소켓 연결
            - HTTP 요청 메시지를 파싱해서 읽기
            - POST 방식 ,/save URL 인지
            - Content-Type 확인
            - HTTP 메시지 바디 내용 확인
                - username, age 데이터를 사용할 수 있게 파싱
            - 저장 프로세스 실행
            - 비즈니스 로직 실행             // 의미있는 비즈니스 로직
                - 데이터베이스에 저장 요청   // 의미있는 비즈니스 로직
            - HTTP 응답 메시지 생성 시작
                - HTTP 시작 라인 생성
                - Header 생성
                - 메시지 바디에 HTML 생성에서 입력
            - TCP/IP 에 응답 전달, 소켓 종료
            ```
            - 위의 모든 단계를 다 거쳐서야(번거롭게) 서버에서 아래의 HTTP 응답 메시지 생성 
            ```
            HTTP/1.1 200 Ok
            Content-Type: text/html;charset=UTF-8
            Content-Type: 3423

            <html>
                <body>...</body>
            </html>
            ```
- 서블릿을 지원하는 WAS 사용
    - 위의 모든 단계들을 직접 다 구현해야 하면 번거로우니까 서블릿 등장!
    - 위의 단계들에서 실질적으로 의미있는 비즈니스 로직은 아래밖에 없다.
    ```
    - 비즈니스 로직 실행
        - 데이터베이스에 저장 요청
    ```
    - 중요) `서블릿은 위의 필수적인 비즈니스 로직을 제외한 모든 것들을 대신 해준다.`

- 서블릿
    - 특징
        - (사진넣기)
        - urlPatterns(/hello)의 URL 이 호출되면 서블릿 코드(아래 코드에서 serivce 메서드)가 실행
        - HTTP 요청 정보를 편리하게 사용할 수 있는 HttpServletRequest
            - 요청 정보를 하나하나 다 파싱해서 사용하면 힘드니까!
            - 그래서 그냥 이 request 객체를 사용하면 된다.
            - ex) `request.getParameter("username");` 이런식
        - HTTP 응답 정보를 편리하게 제공할 수 있는 HttpServletResponse
            - 응답 메시지를 하나하나 다 작성하려면 너무 어렵다. 
        - 개발자는 HTTP 스펙을 매우 편리하게 사용
        - (사진넣기)
        
    ```
    @WebServlet(name = "helloServlet", urlPatterns = "/hello")
    public class HelloServlet extends HttpServlet {

        @Override
        protected void service(HttpServletRequest requset, HttpServletResponse response) {
            // 애플리케이션 로직
        }
    }
    ```
    

- 서블릿, HTTP 요청, 응답 흐름(전체 그림 설명(pdf 18))
    - HTTP 요청시
        - WAS는 Request, Response 객체를 새로 만들어서 서블릿 객체 호출
            - 고객마다 데이터가 다 다르므로 HTTP 요청이 올 때마다 매번 새로 다 생성한다(싱글톤 아님)
        - 개발자는 Request 객체에서 HTTP 요청 정보를 편리하게 꺼내서 사용
        - 개발자는 Response 객체에 HTTP 응답 정보를 편리하게 입력
        - WAS는 Response 객체에 담겨있는 내용으로 HTTP 응답 정보를 생성
        
        
- 서블릿 컨테이너(전체 그림 설명(pdf 20))
    - (사진넣기)
    - `WAS 안에는 서블릿을 지원하는 서블릿 컨테이너가 있다.`
    - 톰캣처럼 서블릿을 지원하는 WAS를 서블릿 컨테이너라고 함
    - 서블릿 컨테이너는 서블릿 객체를 생성, 초기화, 호출, 종료하는 생명주기 관리
    - 서블릿 객체는 `싱글톤`으로 관리(자바 JVM안에서 1개만 존재)
        - 고객의 요청이 올 때 마다 계속 객체를 생성하는 것은 비효율
        - 최초 로딩 시점에 서블릿 객체를 미리 만들어두고 재활용
        - 모든 고객 요청은 동일한 서블릿 객체 인스턴스에 접근
        - `공유 변수 사용 주의`
            - 멤버 변수 사용할 때 조심
        - 서블릿 컨테이너 종료시 함께 종료
    - JSP도 서블릿으로 변환되어서 사용
    - 동시 요청을 위한 멀티 쓰레드 처리 지원
        - 개발자가 따로 의식하지 않아도 WAS가 자동으로 처리


## 동시 요청 - 멀티 쓰레드
- 서버에 요청이 왔을 때 연결(커넥션 연결) 후 servlet 객체를 호출하는데, 서블릿 객체를 누가 호출하나? 바로 쓰레드
- (pdf 25 사진넣기)
- 쓰레드
    - 애플리케이션 코드를 하나하나 순차적으로 실행하는 것은 쓰레드
        - cf) 프로세스는 프로그램 실행하는 것
    - 자바 메인 메서드를 처음 실행하면 main이라는 이름의 쓰레드가 실행
    - 쓰레드가 없다면 자바 애플리케이션 실행이 불가능
    - 쓰레드는 한번에 하나의 코드 라인만 수행
    - 동시 처리가 필요하면 쓰레드를 추가로 생성해 줘야 한다.

- 단일 요청
    - (사진넣기)
    - 쓰레드는 휴식 상태이다가, 요청이 오면 connection 연결 후에 쓰레드를 할당해준다.
    - 이 쓰레드를 통해서 서블릿 코드를 하나씩 실행해준다.
    - 응답 후에는 쓰레드가 다시 휴식

- 다중 요청
    - 쓰레드 하나 사용일 때
        - (pdf 30 사진넣기)
        - 요청1이 들어와서 쓰레드A가 할당이 된 후 서블릿 코드를 실행한다. 그런데 실행 중에 뜻밖의 이유로 처리가 지연이 된다.
        - 그러는 중에 요청2가 들어오게 되면 쓰레드를 할당해줘야 하는데, 쓰레드는 A밖에 없는 상태다. 그래서 쓰레드A를 사용하기 위해 계속 기다려야 한다. 
        - 이렇게 되면 결과는? 둘 다 죽게 된다. 즉 요청1도 처리가 안돼서 지연이 되고 있는 중에(원래는 빨리 다 쓰고 쓰레드A를 반환해줘야 하는데...) 요청2가 수행자체가 안된다.
        - 그래서 결국에는 둘 다 타임아웃이 되면서 죽게 된다.
    - 쓰레드 여럿일 때(요청마다 쓰레드 생성)
        - (pdf 31 사진넣기)
        - 위의 상황과 마찬가지로, 요청1이 들어와서 쓰레드A가 할당이 된 후 서블릿 코드를 실행한다. 그런데 실행 중에 뜻밖의 이유로 처리가 지연이 된다.
        - 그러는 중에 요청2가 들어오는데, 아까와는 달리 기다리지 않고 신규 쓰레드B를 생성한다.
        - 그래서 쓰레드A가 요청 1 처리하는 중에 쓰레드B는 요청2에 대한 응답2를 보내주고 난 후 다시 휴식.
- 요청 마다 쓰레드 생성
    - 장점
        - 동시 요청을 처리할 수 있다.
        - 리소스(CPU, 메모리)가 허용할 때까지 처리가능
        - 하나의 쓰레드가 지연되어도, 나머지 쓰레드는 정상 동작한다.

    - 단점
        - 쓰레드는 생성 비용은 매우 비싸다(CPU도 많이 사용한다)
            - 고객의 요청이 올 때마다 쓰레드를 생성하면, 응답 속도가 늦어진다.(생성하는데 시간이 걸리기 때문에)
        - 쓰레드는 컨텍스트 스위칭 비용이 발생한다.
            - CPU가 사실 몇 코어 정도로 많이 없는데, 하나의 코어가 있다고 가정. 하나의 CPU는 2개의 쓰레드를 계속 왔다갔다 하면서 실행(동시에 실행하는 것이 아니다)
            - 쓰레드가 많을수록 스위칭 비용 증가
        - 쓰레드 생성에 제한이 없다.
            - 고객 요청이 너무 많이 오면, CPU, 메모리 임계점을 넘어서 서버가 죽을 수 있다.
    - 이러한 단점을 보완하기 위해서 대다수의 WAS는 쓰레드 풀을 쓰도록 구현이 되어 있다.

- 쓰레드 풀
    - (사진넣기)
    - (사진넣기)
    - 특징
        - 필요한 쓰레드를 쓰레드 풀에 보관하고 관리한다.
        - 쓰레드 풀에 생성 가능한 쓰레드의 최대치를 관리한다. 톰캣은 최대 200개 기본 설정 (변경 가능)
    - 사용
        - 쓰레드가 필요하면, 이미 생성되어 있는 쓰레드를 쓰레드 풀에서 꺼내서 사용한다.
        - 사용을 종료하면 쓰레드 풀에 해당 쓰레드를 반납한다.
        - 최대 쓰레드가 모두 사용중이어서 쓰레드 풀에 쓰레드가 없으면?
            - 기다리는 요청은 `거절`하거나 특정 숫자만큼 `대기`하도록 설정할 수 있다.
    - 장점
        - 쓰레드가 미리 생성되어 있으므로, 쓰레드를 생성하고 종료하는 비용(CPU)이 절약되고, 응답 시간이 빠르다.
        - 생성 가능한 쓰레드의 최대치가 있으므로 너무 많은 요청이 들어와도 기존 요청은 안전하게 처리할 수 있다.(당연히 서버를 늘리긴 해야 함)
    - 실무 팁
        - WAS의 주요 튜닝 포인트는 최대 쓰레드(max thread) 수이다. 
            - 이걸 통해서 극적인 효과를 보는 경우가 많다.
        - 이 값을 너무 낮게 설정하면?
            - 동시 요청이 많으면, 서버 리소스는 여유롭지만, 클라이언트는 금방 응답 지연
        - 이 값을 너무 높게 설정하면?
            - 동시 요청이 많으면, CPU, 메모리 리소스 임계점 초과로 서버 다운
        - 장애 발생시?
            - 클라우드면 일단 서버부터 늘리고(일단 서비스는 살아있어야 하니까), 이후에 튜닝
            - 클라우드가 아니면(클라우드처럼 서버를 쉽게 늘릴 수 없으니) 열심히 튜닝


- 쓰레드 풀을 낮게 설정했을 경우(반대의 경우는 다 반대)
    - 남은 90개는 다 기다려야 한다.
    - CPU 를 5%밖에 사용안한다? -> 개발자가 셋팅을 잘못한 것임. 그런데 그것도 모르고 막 서버를 늘리는 경우가 종종 있다. 원래 이럴 경우에는 CPU 사용률의 한 50%는 써줘야 한다. 그 말은 하나의 서버로 기존보다 10배의 효과를 낼 수 있다는 말.
    - (사진넣기)

- 쓰레드 풀의 적적 숫자
    - 적정 숫자는 어떻게 찾나요?
    - 애플리케이션 로직의 복잡도, CPU, 메모리, IO 리소스 상황에 따라 모두 다름
        - 꼭 200개 이런건 절대 아니다. 답이 없다.
    - 성능 테스트
        - 오픈하기 전에 꼭 해야 한다.
        - 최대한 실제 서비스와 유사하게 성능 테스트 시도
        - 툴: 아파치 ab, 제이미터, nGrinder(네이버껀데 되게 좋다)

- WAS의 멀티 쓰레드 지원의 핵심
    - `멀티 쓰레드에 대한 부분은 WAS가 처리` -> 이게 제일 핵심이다.
        - 만약 개발자가 직접 멀티 쓰레드를 구현하려고 하면 자바 concurrency 공부해야 하고...매우 힘듦
    - 개발자가 멀티 쓰레드 관련 코드를 신경쓰지 않아도 됨
        - 우리는 서블릿 코드 안에 비즈니스 로직만 넣으면 된다.
    - 개발자는 마치 싱글 쓰레드 프로그래밍을 하듯이 편리하게 소스 코드를 개발
    - 멀티 쓰레드 환경이므로 싱글톤 객체(서블릿, 스프링 빈)는 주의해서 사용
        - 공유 변수 조심

## HTML, HTTP API, CSR, SSR
- 정적 리소스
    - 고정된 HTML 파일, CSS, JS, 이미지, 영상 등을 제공
    - 주로 웹 브라우저
    - (사진넣기)

- 2021.7.2 코딩테스트(프로그래머스)
- tlrtmtiq
- 총 5문제, 120분
- 100%는 5번문제 쿼리만 풀고 나머지 문제들 중 마무리 한 문제는 없었다..
- 문제를 꼼꼼하게 읽지 않아서 당황했음.


# 1.
## 문제
두 문자열의 앞뒤를 겹쳐서 만들 수 있는 문자열 중, 더 짧은 문자열을 구하려 합니다. 예를 들어 "xyZA"와 "ABCxy" 와 "ABCxy"가 주어졌을 때, 두 문자열을 겹치는 방법은 다음과 같습니다.
- 방법 1
    - "xyZA" 뒤에 "ABCxy" 겹치기
    - "xyZ`A`" + "`A`BCxy"
    - -> xyZ`A`BCxy
- 방법 2
    - "ABC`xy`" + "`xy`ZA"
    - "ABC`xy`ZA"
- 두 문자열 s1과 s2가 주어질 때, s1과 s2를 겹쳐서 만들 수 있는 문자열 중, 가장 짧은 문자열을 return 하도록 solution 함수를 완성해주세요.
- 제한사항
    - s1과 s2의 길이는 1이상 100 이하입니다.
    - s1과 s2는 알파벳 대문자와 소문자로만 이루어져 있습니다.
    - 문자열을 겹칠 때는 대소문자를 구분합니다. 즉, "a"와 "A"를 겹칠 수는 없습니다.
    - 가장 짧은 문자열이 여러 개라면 그 중 사전 순으로 앞서는 문자열을 return 해주세요.
- 입출력 예
    - s1 : "xyZA" , s2 : "ABCxy"
        - result : "ABCxyZA"
    - s1 : "AxA", s2 : "AyA"
        - result : "AxAyA"

- 입출력 예 설명
    - 입출력 예 #1
        - 문제에 주어진 예시와 같습니다.
    - 입출력 예 #2
        - 두 문자열을 겹치면 "AxAyA"와 "AyAxA"를 만들 수 있습니다. 둘의 길이는 같으므로 사전 순으로 앞서는 문자열인 "AxAyA"를 return 합니다.

## 시험 중 내 풀이
- 문제를 잘못이해해서 중간에 다시 풀다가 망함

```
class Solution {
    public String solution(String s1, String s2) { // s1 = xyZa, s2 = ABCxy
        String answer = "";
        
        int len = (s1.length() > s2.length()) ? s2.length() : s1.length(); // 4
        
        int cnt = 0;
        int ad_cnt = 0;
        for (int i = 0 ; i < len ; i++) { 
            if (s1.substring(s1.length() - 1 - i) == s2.substring(i, i + 1)) {
                cnt++;
            } else {
                break;   
            }
            
            if (s2.substring(s2.length() - 1 - i) == s1.substring(i, i + 1)) {
                ad_cnt++;
            } else {
                break;          
            }
        }
        
        for (int i = 0 ; i < len ; i++) {		
            
        }
        
        String ans1 = s1 + s2.substring(cnt, s2.length() - 1);
        String ans2 = s2 + s1.substring(cnt, s1.length() - 1);
        
        if (cnt == ad_cnt) {
            // 사전 정렬
            if (ans1.compareTo(ans2) > 0) {
                answer = ans1;
            } else {
                answer = ans2;
            }
            
        } else if (cnt > ad_cnt) {
            answer = ans1;
        } else {
            answer = ans2;
        }
                        
        return answer;
        
    }
}
```

## 다시 풀어본 내 풀이
- 다시 풀어보니 정말 어처구니 없게도 쉬웠다. 긴장x, 다시 본 문제 라서 그런듯. 실제 시험에서 잘 쳐야지 잘하는 실력인듯. 고로 난 아직 쪼렙...후
```
import java.util.Arrays;

class Solution {
    public String solution(String s1, String s2) {
        String answer = "";
        int length = s1.length() < s2.length() ? s1.length() : s2.length();
        int x = 1;
        int a = 0;
        int b = 0;

        while (x <= length) {
            if (s1.substring(s1.length() - x).equals(s2.substring(0, 0 + x))) {
                a = x;
            }

            if (s2.substring(s2.length() - x).equals(s1.substring(0, 0 + x))) {
                b = x;
            }
            x++;
        }

        if (a > b) {
            answer = s1 + s2.substring(a);
        } else if (a < b) {
            answer = s2 + s1.substring(b);
        } else if (a == b) {
            if (a == 0 && b == 0) {
                // 한개도 겹치는 것 없는 경우
                String str1 = s1 + s2;
                String str2 = s2 + s1;
                String[] arr = new String[2];
                arr[0] = str1;
                arr[1] = str2;
                Arrays.sort(arr);
                answer = arr[0];
            } else {
                // 앞 뒤 겹치는 수가 같은 경우
                String str1 = s1 + s2.substring(a);
                String str2 = s2 + s1.substring(b);
                String[] arr = new String[2];
                arr[0] = str1;
                arr[1] = str2;
                Arrays.sort(arr);
                answer = arr[0];
            }

        }

        return answer;
    }

    public static void main(String[] args) {
        Solution s = new Solution();

//        String s1 = "xyZA";
//        String s2 = "ABCxy";

        String s3 = "ksab";
        String s4 = "abks";

        String s5 = "AxA";
        String s6 = "AyA";

//        System.out.println(s.solution(s1, s2));
        System.out.println(s.solution(s3, s4));
        System.out.println(s.solution(s5, s6));
    }
}
```


# 2.
## 문제
- N명의 학생이 시험을 보았습니다. 각 학생에는 1부터 N까지의 번호가 붙어있습니다. N명의 학생의 시험 점수를 바탕으로 등수를 부여하려고 합니다. 각 학생의 등수는 자신보다 높은 점수를 받은 학생의 수에 1을 더한 수입니다. 예를 들어, 세 학생이 있고 1, 2, 3번 학생의 성적이 각각 2, 2, 1 이라면 1, 2번 학생은 가장 점수가 높고 동점이기 때문에 1등이고, 3번 학생은 1, 2번 학생보다 점수가 낮기 때문에 3등입니다. 1번부터 N번 학생까지의 점수가 순서대로 들어있는 배열 `grade` 가 주어질 때 1번부터 N번 학생까지의 등수가 순서대로 들어있는 배열을 return 하도록 solution 함수를 완성해주세요.
- 제한사항
    - grade의 길이는 1 이상 1,000,000 이하 입니다.
    - grade의 각 원소는 1 이상 1,000,000,000 이하입니다.
    
- 입출력 예

    |grade|result|
    |--|--|
    |[2, 2, 1]|[1, 1, 3]|
    |[3, 2, 1, 2]|[1, 2, 4, 2]|

- 입출력 예 설명
    - 입출력 예 #1
        - 문제 예시와 같습니다.
    - 입출력 예 #2
        - 1번 학생은 가장 점수가 높기 때문에 1등, 2번 학생은 자신보다 높은 점수의 학생이 1번 학생밖에 없으므로 2등, 3번 학생은 자신보다 높은 학생이 1번, 2번, 4번 학생이기 때문에 4등, 그리고 4번 학생은 2번 학생과 마찬가지로 자신보다 높은 점수의 학생이 1번 학생밖에 없으므로 2등입니다.
    
- 제출 답 양식
```
class Solution {
    public int[] solution(int[] grade) {
        int[] answer = new int[grade.length];
        
        
        return answer;
    }
}
```




# 3.

- 다시 풀어보니 내가 생각하는 방향(좀 더 단순하게 생각했음)과는 조금 달랐다.

## 문제

택배를 이용해 총 n개의 옷을 배송하려고 합니다. 택배 회사에는 현재 옷 3개, 5개를 담을 수 있는 상자가 준비되어 있습니다. 상자의 크기에 상관없이 상자의 개수로 배송비를 받기 때문에, 상자의 개수를 최소한으로 줄이려고 합니다. 단 상자를 보내기 위해서는 상자에 반드시들어갈 수 있는 옷이 모두 들어가야 합니다. 즉, 옷을 2개만 담은 상자는 배송할 수 없습니다. 보내야 할 옷의 개수 n이 주어질 때, 배송비를 최소화할 수 있는 상자의 개수를 return하도록 solution 함수를 완성하세요. 어떠한 방법으로도 모든 옷을 보낼 수 없다면 -1을 반환하면 됩니다.

- 제한사항
  - 옷의 개수 n : 3 <= n <= 1,000,000,000
- 입출력 예

  - n이 15일 때 result 3
  - n이 7일 때 result -1

- 입출력 예 설명
  - 입출력 예 #1
    - n = 15 라면 5개들이 상자 3개에 나누어 배송하는 것이 최적의 방법이므로 3을 반환합니다.
  - 입출력 예 #2
    - n = 7 이라면 위의 규칙으로 배송할 방법이 없으므로 -1을 반환합니다.

## 시험 중 내 풀이

- n이 15, 7일 때는 풀었는데 다른 테스트 케이스 통과 못함

```
class Solution {
    public int solution(int n) {
        int answer = 0;

        if (n/5 ==0) {
            answer = n/5;
        } else if (n/5 > 1) {
            answer = n/5;
            int k = n%5;
            if (k%3 != 0) {
                return -1;
            } else {
                answer += k/3;
            }
        } else {
            if (n%3 != 0) {
                return -1;
            } else {
                answer = 1;
            }
        }

        return answer;
    }
}
```

## 다시 풀어본 내 풀이
- 여러 값들 넣어보니 정답 다 나옴.
- 천천히 풀어보니 정말 쉬운 문제...

```
class Solution {
    public int solution(int n) {
        int answer = 0;
        int after = 0;

        if (n % 5 == 0) {
            answer = n / 5;

        } else {
            while(n >= 3) {
                int k = 1;
                n -= 3 * k;
                if (n % 5 == 0) {
                    answer += k;
                    answer += n / 5;
                    return answer;
                }
                k++;
            }

            answer = -1;
        }

        return answer;
    }

    public static void main(String[] args) {

        Solution s = new Solution();
        System.out.println(s.solution(53));
        System.out.println(s.solution(41));
        System.out.println("-1 이어야 함 " + s.solution(4));
        System.out.println(s.solution(2));
        System.out.println(s.solution(39));
        System.out.println(s.solution(33));

//        int a = 2;
//        int n = 10;
//        n -= 3 * a;
//        System.out.println(n);

    }
}

```

# 4.

## 문제
- 한 번에 최대 N 잔까지 동시에 커피를 추출할 수 있는 커피 추출기가 있습니다. 이 커피 추출기를 이용해 커피를 만들 때, 커피가 만들어지는 순서를 구하려 합니다. 만들어야 하는 커피가 M잔이면, 커피에 1부터 M까지 순서대로 주문번호가 붙어있습니다. 또, 주문번호 순으로 빈 커피 추출구에서 커피를 만들기 시작합니다. 만약 빈 추출구가 없다면, 빈 추출구가 생길 때까지 다음 주문은 잠시 기다리며, 빈 추출구가 생기면 대기 중인 다음 커피를 즉시 만들기 시작합니다. 모든 커피는 만드는데 일정 시간이 소요되는데, 소요 시간은 커피 종류별로 다를 수 있습니다. 따라서 커피 제조 시간에 따라 각 주문이 완료되는 순서는 다를 수 있습니다. 커피 추출구 개수 N, 각 커피를 만드는데 걸리는 시간이 주문번호 순서대로 담긴 배열 coffee_times가 매개변수로 주어질 때, 커피가 완성되는 순서대로 주문번호를 배열에 담아 return 하도록 solution 함수를 완성해 주세요. 단, 커피 주문이 추출구에 배정되는데 걸리는 시간은 없다고 가정하며, 커피 추출이 동시에 완료됐을 경우 작은 주문번호가 앞에 오도록 하면 됩니다.


- 제한사항
    - N은 1이상 10,000 이하인 자연수
    - coffee_times의 길이는 1이상 300,000 이하
    - coffee_times의 원소는 1이상 100,000,000 이하인 자연수
- 입출력 예

    |N|coffee_times|result|
    |--|--|--|
    |3|[4, 2, 2, 5, 3]|[2, 3, 1, 5, 4]|
    |1|[100, 1, 50, 1, 1]|[1, 2, 3, 4, 5]|


- 입출력 예 설명
    - 입출력 예 #1
        - 커피 추출구 개수 N = 3이고, 커피별 제조시간은 주문 번호 순서대로 [4초, 2초, 2초, 5초, 3초]입니다.

        |시간(초)|제작중 커피(주문 번호)|완료 순서|
        |--|--|--|
        |0|[1번, 2번, 3번]|[]|
        |1|[1번, 2번, 3번]|[]|
        |2|[1번, 4번, 5번]|[2번, 3번]|
        |3|[1번, 4번, 5번]|[2번, 3번]|
        |4|[4번, 5번]|[2번, 3번, 1번]|
        |5|[4번]|[2번, 3번, 1번, 5번]|
        |6|[4번]|[2번, 3번, 1번, 5번]|
        |7|[]|[2번, 3번, 1번, 5번, 4번]|
        - 빈 추출구 3곳에 1, 2, 3번 주문이 동시에 배정됩니다.
        - 2초가 지나면 2, 3번 커피가 다 만들어지고, 빈 추출구에 4, 5번 주문이 배정됩니다.
        - 4초가 지나면 1번 커피가 완료되며, 5번 주문이 배정됩니다.
        - 배정 후 3초가 지난 5초에 5번 주문이 완료됩니다.
        - 배정 후 5초가 지난 7초에 4번 주문이 완료됩니다.
        - 따라서 [2, 3, 1, 5, 4]를 return 하면 됩니다.
    - 입출력 예 #2
        - 커피 추출구 개수 N = 1이므로, 한 번에 한 잔씩 커피를 만들 수 있습니다. 따라서 커피는 주문번호 순서대로 완성됩니다.
- 제출 답 양식
```
class Solution {
    public int[] solution(int N, int[] coffee_times) {
        int[] answer = {};
        return answer;
    }
}
```

# 5.

- 2021.7.3 코딩테스트(codility)
- zmffotm101
- 총 3문제, 75분
- 1번 문제는 쉽게 풀었는데 2번 문제는 거의 풀기 직전까지 갔다가 못 풀었음..



# 1.
## 문제
Complete an implementation of a function solution, that should return a string describing first character of the given string: "digit" for a digit, "lower" for a lowercase letter, "upper" for an uppercase letter and "other" for other characters. You can assume the characters are ASCII.
- 답안 포맷

```
import java.util.*;

class Solution {

    public String solution(String s) {
        char c = s.charAt(0);
        if ___ { // please fix condition
            return "upper";
        } else if ___ { // please fix condition
            return "lower";
        } else if ___ { // please fix condition
            return "digit";
        } else {
            return "other";
        }
    }

}
```
## 시험 중 내 풀이
    - 테스트 통과
    ```
    class Solution {
        public String solution(String s) {
            char c = s.charAt(0);
            if ( (int)c >= 65 && (int)c <= 90) {  // please fix condition
                return "upper";
            } else if ( (int)c >= 97 && (int)c <= 122 ) {  // please fix condition
                return "lower";
            } else if ( ('0' <= c && c <= '9')) {  // please fix condition
                return "digit";
            } else {
                return "other";
            }
        }

    }
    ```
## 다시 풀어본 내 풀이
    - 아래가 더 깔끔
    - 그런데 3번째 조건에서 '0', '9' 대신에 그냥 0, 9를 하면 숫자로 인식하지 못한다.

```
class Solution {
    public String solution(String s) {
//        char c = s.charAt(0);
        int c = s.charAt(0);

        if ( c >= 65 && c <= 90) {  // please fix condition
            return "upper";
        } else if ( c >= 97 && c <= 122 ) {  // please fix condition
            return "lower";
        } else if ( ('0' <= c && c <= '9')) {  // please fix condition
            return "digit";
        } else {
            return "other";
        }
    }
```

# 2.
## 문제
- A company has a list of expected revenues and payments for the upcoming year in chronological order. The problem is that at some moments in time the sum of previous payments can be larger than the total previous revenue, which would put the company in debt. To avoid this problem the company takes a very simple approach: it reschedules some expenses to the end of the year.
- You are given an array of integers, where positive numbers represent revenues and negative numbers represent expenses, all in chronological order. In one move you can relocate any expense (negative number) to the end of the array. What is the minimum number of such relocations to make sure that the company never falls into debt (in other words: you need to ensure that there is no consecutive sequence of elements starting from the beginning of the array, that sums up to a negative nubmer)?
- You can assume that the sum of all elements in A is nonnegative.
- Write a function:
    ```
    class Solution { public int solution(int[] A); }
    ```
that, given an array A of N integers, returns the minimum number of relocations, so that company never falls into debt.
- Examples
    1. Given A = [10, -10, -1, -1, 10], the function shoudl return 1. It is enough to move -10 to the end of the array.
    2. Given A = [-1, -1, -1, 1, 1, 1, 1], your function should return 3, The negative elements at the beginning must be moved to the end to avoid the debt at the start of the year.
    3. Given A = [5, -2, -3, 1], the answer is 0. The company balance is always nonnegative.

- Write an efficient algorithm for the following assumptions;
    - N is an integer within the range [1...100,000];
    - each element of array A is an integer within the range [-1,000,000,000 ... 1,000,000,000];
    - sum of all elements in A is greater than or equal to 0.


## 시험 중 내 풀이
    - 못 품
    - 메인 메서드에서 테스트 해보는데, 각각 다 1, 3, 0이 나와야 하는데 다 2 2 2 가 나와서 잘못됨.
```
class Solution {

    public int solution(int[] A) {
        int cnt = 0;
        int sum = 0;

        int[] tempArr = new int[A.length];
        for (int i = 0 ; i < A.length ; i++) {
            sum += A[i];
            if (sum < 0) {
                if (i == 0) {
                    // 자리 배치
                    int temp = A[0];
                    for (int k = 0 ; k < A.length - 1 ; k++) {
                        A[k] = A[k+1];
                    }
                    A[A.length - 1] = temp;

                    // 횟수증가
                    cnt++;

                    // 0으로 되돌리기.
                    sum = 0;
                    i = 0;
                } else {
                    // 자리 배치
                    int temp = A[i-1];
                    for (int j = i ; j < A.length - 1 ; j++) {
                        A[j-1] = A[j];
                    }
                    A[A.length - 1] = temp;
                    // 값 되돌리기 (이전의 값의 절대값 더해주기)
                    sum += Math.abs(i-1);

                    // 값 되돌리기 (이전의 값의 절대값 더해주기)
                    sum += Math.abs(i-1);

                    cnt++;
                }
            }
        }
        return cnt;
    }
}
```

## 새로 푼 내 풀이
- 다시 풀어봐도 좀 까다로웠다.
- 우선 큰 반복문 while문을 기본적인 for문으로 하려니까 배열의 순서(i)를 간단하게 다룰 수 없었고 그래서 테스트에서 꼬인 듯
- 그리고 A에서 제일 처음에 -1가 들어왔을 때 어떻게 처리했어야 했는지 고민이 필요했다.
- B에서도 계산을 해서 제일 뒤로 보낸건 초기화 해야 하니까 다시 처리. 그리고 -=, += 에서 음수를 연산할 떄 혹시나 집집해서 절대값으로 하면 더 명확하고 빠름. 대신 속도가 느릴 듯
- C가 은근히 생각하기 까다로웠다. C부분에 단순히 seq-- 라고 했으면 2줄 밑의 seq++에서 계속 제자리. 그래서 한 칸씩 건너뛰어서 연산이 되었다.

```
class Solution {
    public int solution(int[] A) {
        int moveNum = 0;
        int seq = 0;
        int sum = 0;

        while (seq < A.length) {
            sum += A[seq];
            if (sum < 0) {
                if (seq == 0) { // A
                    seq++;
                }
                
                // relocate the number to the end of the Array.
                for (int i = seq - 1 ; i < A.length - 1 ; i++) {
                    int temp = A[i];
                    A[i] = A[i + 1];
                    A[i + 1] = temp;
                }

                sum += Math.abs(A[A.length - 1]);  // B
                seq--;
                moveNum++; 
                continue; // C
            }
            seq++;
        }

        return moveNum;
    }
```

# 3. 
## 문제
- You are given an implementation of a function;
    ```
    class Solution {
        public boolean solution(int[] A, int K);
    }
    ```
- This function, given a non-empty array A of N integers (sorted in non-decreasing order) and integer K, checks whether A contains numbers 1, 2, ..., K (every number from 1 to K at least once) and no other numbers;
- For example, given the following array A, and K = 3;
    ```
    A[0] = 1
    A[1] = 1
    A[2] = 2
    A[3] = 3
    A[4] = 3
    ```
    - The function should return true.
- For the following array A, and K = 2:
    ```
    A[0] = 1
    A[1] = 1
    A[2] = 3
    ```
    - the function should return false
- The attached code is still incorrect for some inputs. Despite the error(s), the code may produce a correct answer for the example test cases. The goal of the exercise is to find and fix the bug(s) in the implementation. You can modify at most two lines.

- Assume that:
    - N and K are integers within the range [1...300,000];
    - each element of array A is an integer within the range [0...1,000,000,000];
    - array A is sorted in non-decreasing order.
- In your solution, focus on correctness. The performance of your solution will not be the focus of the assessment.

## 답안 포맷
```
class Solution {
    public boolean solution(int[] A, int K) {
        int n = A.length;
        for (int i = 0; i < n - 1; i++) {
            if (A[i] + 1 < A[i + 1])
                return false;
        }
        if (A[0] != 1 && A[n - 1] != K)
            return false;
        else
            return true;
    }
}
```


## 시험 중 내 풀이
- 읽지도 못했음. ㅡㅡ; 2번에 빠져서...



## 다시 풀어본 내 풀이
- arr = {1, 2, 2, 2, 2}, K = 3일 때 위의 기존 조건일 경우는 true, 그런데 원래는 false가 나와야 한다.(3이 없으므로) -> 그래서 `!=` 조건에서 `<` 으로 수정
- arr = {2, 2, 2, 2, 3}, K = 3일 때 위의 기존 조건일 경우는 true, 그런데 원래는 false가 나와야 한다. (1이 없으므로) -> 그래서 `&&` 조건에서 `||` 으로 수정
- 다른 부분 수정해야 하는지는 잘 모르겠다. 다른 테스트 코드 예제가 없어서...
```
class Solution {
    public boolean solution(int[] A, int K) {
        int n = A.length;
        for (int i = 0 ; i < n - 1 ; i++){
            if (A[i] + 1 < A[i + 1]) 
                return false;
        }
        if (A[0] != 1 || A[n-1] < K)  { // K조건 수정
            return false;
        else 
            return true;
    }
}
```
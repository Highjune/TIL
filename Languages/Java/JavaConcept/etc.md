# etc 기타

- 생성자

  - 멤버변수 초기화가 목적. 필드(name, age 등)를 초기화할 때 2가지 방법.
    1. 필드를 선언할 때 초기화(동일한 클래스로부터 생성되는 객체들은 모두 같은 값을 갖는다)
    2. 생성자에 초기값 주는 방법.
  - 클래스가 public class로 선언되면 기본 생성자에서도 public이 붙지만, 클래스가 public 없이 class로만 선언되면 기본 생성자에도 public이 붙지 않는다.
  - 모든 클래스는 생성자가 반드시 존재, 생성자를 하나 이상 가질 수 있다. 클래스 내부에 생성자 선언을 생략했다면 컴파일러는 기본생서자를 바이트 코드 파일(.class)에 자동 추가한다.
  - 그렇기 때문에 클래스에 생성자를 선언하지 않아도 다음과 같이 new 연산자 뒤에 기본 생성자를 호출해서 객체 생성 가능

  ```
  Student s = new Student():
  ```

  - 그러나 클래스에 명시적으로 선언한 생성자가 1개라도 있으면 컴파일러는 기본 생성자를 추가하지 않는다. 명시적으로 생성자를 선언하는 이유는 객체를 다양한 값으로 초기화하기 위해서다.
  - 생성자는 메서드와 비슷한 모양이지만 리턴 타입이 없고 클래스 이름과 동일하다.

- 파라미터로 인터페이스 그 자체를 받는 경우(인터페이스를 구현한 클래스가 다형성을 통해 들어오는 경우 말고)
  ```
  public void bubblesort() {
  	Collections.sort(this.vector, new Comparator<Student>(){
  		@Override
  		public int compare(Student s1, Student s2) {
  			return s1.getTot() > s2.getTot() ? -1 :
  				s1.getTot() == s2.getTot() ? 0 : 1;
  		}
  	});
  }
  ```
  - 인터페이스 comparator를 받게 되면 그 ( ) 안에서 추상메서드를 구현해 줘야 한다. 만약 그 안에 추상메서드가 n개이면 다 구현해 줘야 한다.
  - 그런데 보통 파라미터를 인터페이스로 받는 경우에는 그 인터페이스 안에 추상메서드가 보통 1개밖에 없다.
  - 이를 편리하게 하기 위해 만든 것이 람다. 람다는 추상메서드가 1개인 경우에만 사용가능

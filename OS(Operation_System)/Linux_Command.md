- [만화로 배우는 리눅스 시스템관리 1](http://www.yes24.com/Product/Goods/30705473)를 보고 정리한 내용

# 개념
- 셸(shell)
  - 사용자가 콘솔 환경에서 대화식으로 명령어를 입력하면서 사용하는 소프트웨어
  - 리눅스에서 bash나 dash라는 셸을 사용하는 경우 많음
  - vim으로 텍스트 편집하거나 grep으로 파일을 찾을 때, 이런 다양한 소프트웨어를 사용자 요구에 따라 실행하거나 조작을 돕는 게 셸의 역할
  - GNOME 단말은 셸인가?
    - No. GNOME 단말은 GUI 환경에서 셸을 실행하기 위해 사용하는 것으로 셸 자체가 아니다. tmux, ssh 도 마찬가지. 셸이라는 소프트웨어에 입력(vim 등)을 부탁하는 것


# 우분투 및 패키지 

## 우분투 패키지 관리툴 업데이트
```
sudo apt-get update
```

# 리눅스 명령어

## 명령어 내역 확인

```
history
```

또는

```
vim ~/.bash_history
```

## root 권한 얻기

- 아래 명령어 후 비밀번호 권한 받기.
- root 권한으로 명령어 실행하면 일반 user가 접근 못한다.

```
sudo su
```

## 리눅스에서 프로세스를 실행한 터미널의 세션 연결이 끊어지더라도 지속적으로 동작 할 수 있게 해주는 명령어

```
nohup
```

## 백그라운드에서 실행 명령어

```
&
```

## 실행중인 프로세스 확인

```
ps
```

- 옵션
  - `e` 실행중인 모든 프로세스의 정보
  - `f` 프로세스에 대한 자세한 정보 출력 (ppid 확인 가능)
  - ex) 현재 실행중인 프로세스의 자세한 정보 + 'api' 단어 확인, api, 'api', "api" 다 가능
  ```
  ps -ef | grep api
  ```

## 실행중인 프로세스 id만 획득
- ps 와 grep 명령어 합친 것
```
pgrep 프로세스명
```
- ex) `java` -jar ~~~~~~~~ `admin-test` 을 포함하는 pid 반환
  - `-f`를 붙여줘야만 나오는 듯 (찾아보기)
  ```
  pgrep -f "java.*admin-test"
  ```
  - 또는 쉘 스크립트에서 변수를 사용한다면. ``로 구분
  ```
  CONFIG_TYPE=backend-test

  getpid() {
    pid=`pgrep -f "java.*$CONFIG_TYPE"`
  }
  ```

## 명령어 후방(밑 방향으로) 검색
- 한번 입력한 명령어를 위아래 방향키로 하나하나 찾지 말고 바로 검색해서 사용할 수 있음
```
history
ctrl + r 후에 찾고자 하는 것 입력 ex) vim 후에 ctrl + r 계속 누르면서 찾기.(위로 올라감)
```

## 명령어 전방(위 방향으로) 검색

- 설정 변경이 필요함

```
vim ~/.bashrc // 설정 파일 열기
shift + g  // 파일 마지막으로 이동
stty stop undef 입력
```

- 콘솔 환경에 재로그인. bash를 재실행해서 새로운 설정을 읽어 들이는 것
- `ctrl + s` 후에 찾고자 하는 것 입력 ex) vim 후에 `ctrl + s` 계속 누르면서 찾기.(아래로 내려감)
- `ctrl + s 는 초기상태에서는 다른 조작이 할당되어 있다. 그 설정을 변경해서 bash에서 `ctrl + s` 명령어를 사용할 수 있게 한 것
- 다른 서버에서도 전방 검색을 하려면 그 서버에서도 위와 같은 설정이 필요하다.

## 파일 끝으로 이동

```
shift + g
```

## 파이프라인(|)

- 어떤 명령어 실행 결과 출력을 그대로 다른 명령어에 넘김. 즉 앞의 출력이 뒤의 입력이 됨
- 받는 쪽 명령어는 열어야 할 파일 지정을 생략한다.
- 여러 번 사용 가능
- 콘솔 애플리케이션에서 사용가능한 것이지 GUI애플리케이션 다수에서는 사용 못함
- 아래 예에서는 grep 출력이 그대로 less의 입력이 되어서 긴 파일을 여는 것처럼 조작 가능
- ex1) access.log.1 파일에서 "/retro" 내용을 포함한 줄을 찾은 후 less로 출력
```
grep "/retro" access.log.1 | less
```
- ex2) 
  - 중간의 grep -v "/live" 는 앞의 출력결과에서 지정한 문자열(/live) 을 포함하지 않는 줄만 출력 
  ```
  grep "/retro" access.log.1 | grep -v "/live" | less
  ```

## `top` 시스템 상태 전반적으로 확인(cp, memory, process)

- `shift + m` 메모리사용률 내림차순으로, `shift + t` CPU시간 순서, `shift + p` CPU 사용량 순서.
- (shift + m 누른 후) `c` 상세표시 전환

```
top
shift + m
c
q(top 모드 종료, quit 의미)
```

## 실행중인 프로세스 종료
```
kill PID
```

- 다른 사용자의 프로세스라면 sudo 붙여야됨
```
sudo kill PID
```

- 여러 프로세스 ID를 동시에 띄워서 나열하면 동시에 종료 가능
```
sudo kill 111 222 333 444 ...C
```

## 파일, 디렉토리 삭제

- rm는 파일은 삭제할 수 있지만 디렉토리는 삭제하지 못한다. 디렉토리와 그 내용물을 모두 삭제하려면 rm -r 으로 하면 된다. 이 때 정말 삭제하시겠습니까 ? 라는 문구가 각 파일 하나씩 다 나온다
- 삭제 질문이 뜨지 않게 하려면 rm -rf으로. rm -rf는 확인절차 없이 삭제하므로 극도로 조심해서 사용해야 한다. 리눅스에서는 삭제된 파일이나 디렉토리를 절대 복구 못한다.
- cf) rm 이라고 치면 도움말을 확인할 수 있다.
- (찾아보기)

```
rm -r 디렉토리_이름
rm -rf 디렉토리_이름

rmdir -r 디렉토리_이름
rmdir -rf 디렉토리_이름
```


## grep

- `-r`은 서브 폴더까지 검색하도록 지정. 재귀적으로 찾는 것임
- `-i`는 ignore case, 즉 알파벳 대문자, 소문자 차이 무시하고 검색
- 포맷)
  ```
  grep -r -i "검색하고 싶은 문자열" 찾을 파일이 있는 폴더 경로(검색 시작점) 및 파일
  ```
- `-E` 정규 표현식을 사용할 때 앞에 붙임.
- 정규 표현식들
  - `()` 그룹화
  - `|` 좌우 중 하나
  - `?` 직전 표현이 0회 또는 1회 등장
  - `*` 직전 표현이 0회 이상 연속해서 등장
  - `+` 직전 표현이 1회 이상 연속해서 등장
  - `.` 임의의 한 문자
  - `^` 줄 머리
  - `$` 줄 끝
- 압축 파일은 grep으로 직접 쓸 수 없다. zcat 등의 로그 파일 압축 형식에 맞는 명령어로 열어야 한다.

- ex1) /home/docs/ 밑에 있는 모든 파일안에서 대소문자 무관하게 "api" 단어를 가진 파일과 그 문자열을 다 찾아낸다
```
grep -r -i "api" /home/docs/
```
- ex2) 정규식 예제
  - `honggildong`, `hong gildong`, `hong    gildong`, `홍 길동`, `홍길동` 으로 된 것을 /home/desc/ 디렉토리 밑에서 대소문자 무시하고 찾기. *는 hong 이후에 직전 표현(스페이스)가 0회 이상 반복해서 등장한 것을 의미. +는 직전 표현(스페이스)이 1회 이상 연속해서 등장
  ```
  grep -r -i -E "((hong) *(gildong)|홍 +길동)" /home/docs/
  ```
- 아래처럼 -r옵션이 없으면 파일 안에서 지정한 내용을 포함한 줄을 찾을 수 있다. 
```
grep "orange" /var/log/apache2/access.log
```

## 로그 파일 압축 출력

- 오래된 로그 파일은 디스크 용량을 아끼기 위해 압축한다. 그 압축파일들을 grep으로 직접 사용할 수 없다.
- `cat` 비압축 테스트 파일용. 지정한 파일 내용을 읽어서 그대로 출력
- `zcat` gzip형식 전용 .gz .tgz 가능
- `xcat` xz형식 전용 .xz 가능
- `unzip` zip형식 전용

## 지금 이 순간 실시간 로그 확인

- 실시간으로 로그가 추가되는 것을 바로 확인
- tail은 파일 내용 끝부분만 출력
- `-F` 옵션은 파일 변경을 감시해서 로그 파일에 내용이 추가될 때마다 그 부분을 실시간으로 출력

```
tail -F access.log
```

## cut

- 필요한 줄만 뽑고 싶을 때
- 포인트는 구분자(delimiter), 구분자는 글자 하나만 지정 가능
- 옵션은 -d, -f 2가지. 보통 2가지를 같이 쓴다.
  - `-d` 구분자
  - `-f` 추출할 위치

```
--delimiter "구분자"
또는
-d "구분자"

--fields 추출할 위치
또는
-f 추출할 위치
```

- ex1) " " 공백으로 끊었을 때 7번째 것

```
cut -d " " -f 7
```

- ex2) access.log에서 "/live" 포함한 것 빼고, 공백으로 끊었을 때 7번째 것을 출력

```
cat /var/log/apache2/access.log | grep -v "/live" | cut -d " " -f 7 | less
```
- ed3) "를 구분자로 쓸 때는 '(홑따옴포)로 감싸면 됨
```
cut -d '"' -f 6
```

- 일부열만 제거하는 것도 가능
- 그래서 CSV(Comma Separated File) 파일을 cut을 써서 간단히 열 단위로 정보 추출 가능
  - `-f` 옵션으로 열 번호 지정, 여러 숫자를 지정하거나 열 범위를 지정할 수도 있다.
  - 연속한 열일 경우 `범위 시작-끝`
  ```
  cat items.csv | cut -d "," -f 1-3
  ```
  - 어떤 열 이후의 모든 열을 지정한다면 끝을 생략하고 `시작-`, 아래는 4열부터 모든 열 지정
  ```
  cat items.csv | cut -d "," -f 4-
  ```
- cut 구분자 문자가 지정되지 않으면 cut명령어는 `탭문자를 구분자로 사용`한다. 셸 스크립트 안에서라면 `cut -d "(탭문자)"`로 사용가능. 
```
cat text.txt | cut -f 2 | less // text.txt파일에서 탭으로 구분된 것 중 2번째 것을 출력
```



## sort와 uniq

- 같은 내용의 줄을 셀 때 유용
- 둘은 거의 붙어다님
- sort는 알파벳 순서로 재정렬. 각 줄의 내용을 앞에서부터 비교해서 숫자순, 알파벳순으로 정렬. 기본은 오름차순. `--reverse` 또는 `-r`옵션은 내림차순

```
cat input.txt | sort
```

- uniq는 중복제거
  - 그런데 연속으로 위치해있는 중복밖에 제거하지 못한다. 같은 내용이 띄엄띄엄 있으면 중복제거 하지 못함.
  ```
  cat input.txt | uniq
  ```
- sort와 uniq를 동시에 사용
  - 미리 sort해서 정렬후에 uniq하면 띄엄띄엄 있는 것들을 서로 붙여놨으니 중복 제거 가능
  ```
  cat input.txt | sort | uniq
  ```
- uniq는 같은 내용이 몇 번 등장했는가를 셀 수도 있다. `--count`옵션, `-c` 도 마찬가지.

  - 참고) `uniq -c` 옵션은 숫자가 오른쪽 정렬이다. `uniq -c` 결과는 sort에서 사용하는 경우가 많으니까 `단순 정렬`로도 문제없도록 만들어 둔 것.

  ```
  uniq -c
  ```

  - 위와 같이 쓰게 되면 제일 앞에 횟수가 나온다. 즉 중복도 제거하고 등장 횟수도 셈
  - ex) 접속한 페이지 경로 목록에 같은 경로의 등장 횟수 세기

  ```
  cat /var/log/apache2/access.log | grep -v "/live" | cut -d " " -f 7 | sort | uniq -c | less
  ```

  - 위와 같은 uniq 결과를 보면 경로 등장 횟수가 줄 맨 앞에 출력되어 있다.
  - 그래서 위의 결과를 파이프 라인을 통해 다시 sort 로 보내면 된다.

  ```
  cat /var/log/apache2/access.log | grep -v "/live" | cut -d " " -f 7 | sort | uniq -c | sort | less
  ```

  - 역순. sort에 `-c` 옵션

  ```
  cat /var/log/apache2/access.log | grep -v "/live" | cut -d " " -f 7 | sort | uniq -c | sort -c | less
  ```

  - 모든 것에 대한 목록(오름차순이든 내림차순이든)은 필요없으니 tail, head 명령어를 사용하면 된다.

  ```
  cat /var/log/apache2/access.log | grep -v "/live" | cut -d " " -f 7 | sort | uniq -c | sort -r | tail
  ```

- 예시(shell script로)

```
#!/bin/bash
log=/var/log/apache2/access.log
count=10

echo "접속수가 많은 ${count}개 페이지:"
cat $log | grep -v "/live" | cut -d " " -f 7 | sort | uniq -c | sort -c | head -n $count

echo "접속수가 적은 ${count}개 페이지:"
cat $log | grep -v "/live" | cut -d " " -f 7 | sort | uniq -c | sort -c | tail -n $count
```

- sort명령어도 cut처럼 특정 구분자로 나누는 기능이 있다.
  - 구분자 지정은 `--field-separator` 또는 `-t`
  - `--key`, `-k`옵션으로 `열 번호를 지정하면 그 열 내용`으로 재정렬
  - ex) , 를 구분자로 구분했을 때 3번째 열 기준으로 정렬
  ```
  sort -t "," -k 3
  ```
  - 그런데 sort는 문자열을 한 문자씩 비교해서 재배치하므로 `단순정렬` 기준이다. 예를 들어 `10`은 `2`보다 앞에 정렬이 되는 것처럼. 왜냐하면 `10`의 `1`이 `2`보다 앞이므로 앞에 정렬되는 것임.
  - `숫자정렬`을 하려면 `--number` 또는 `-n` 옵션.
  - ex)
  ```
  cat items.csv | cut -d "," -f 1-3 | sort -t "," -k 3 -n | less
  ```
- `-b`옵션은 ?
  - `uniq -c` 결과는 기본적으로 숫자가 오른쪽 정렬이라 sort에서 `단순 정렬` 하더라도 문제가 없긴 했었다. 아래에서 숫자가 하나뿐인 1(Debian), 2(Ubuntu)가 앞자리가 비어 있으므로 11, 10가 더 뒤로 밀린 후, 10, 11중에서도 일의자리끼리 비교해서 0 -> 1순서로 배치
  ```
   1, Debian
   2, Ubuntu
  10, Fedora
  11, Red Hat
  ```
  - 하지만 스페이스로 칸을 채워서 오른쪽으로 줄맞춤한 문자열은 단순 정렬해도 기대한 것과 다른 결과.
  - 그래서 `--ignore-leading-blanks` 또는 `-b` 옵션을 사용하면 오른쪽 줄맞춤을 위해서 넣은 스페이스를 무시하고 문자열을 정렬할 수 있다(test 파일 넣어서 시험해보기)
  - 데이터 예시
  ```
   8,          딱풀, 44, 220, 재고없음
   9,      샤프펜슬, 50, 401, 재고있음
  10,          볼펜, 10, 222, 재고있음
  ```
  - `-b`옵션 사용 예시
  ```
  cat items.csv | cut -d "," -f 1-3 | sort -t "," -k 2 -b
  ```

## 리다이렉트 >, >>
- [표준입출력과 그 쓰임새](https://etloveguitar.tistory.com/m/20)

- 명령어 실행 결과를 저장하는 기본 테크닉
- `|`대신에 `>`를 사용하면 보통은 파이프라인으로 넘어가는 것과 같은 내용이 텍스트 파일로 출력된다.
- `>`가 하나뿐인 리다이렉트는 이미 파일이 있으면 지우고 새로운 파일 만든다. `>`를 두 번 이어서 쓴 `>>` 리다이렉트면 기존 파일에 추가한다.
- 그래서 `>`는 파일명이 같으면 덮어쓰므로 반드시 다른 이름을 지정해야 한다.
- ex)
```
cat items.csv | cut =d "." -f 1-3 | sort -t "," -k 3 -n > ./items-sorted.csv
echo "12345, 추가항목, 0" >> ./items-sorted.csv
```

- 위처럼 `echo`명령어를 사용해서 임의의 문자열을 파일에 추가 가능하다.

## tail, head

- tail은 파일이나 파이프라인 입력 `끝에서` 10줄만 추출하는 것 (ex. 10줄은 예시)
- head는 파일이나 파이프라인 입력 `앞에서` 10줄만 추출하는 것
- `-n`옵션으로 출력하는 줄 수 조정 가능
  - 앞에서부터 3줄 추출
  ```
  head -n 3
  ```
  - 뒤에서부터 3줄 추출
  ```
  tail -n 3
  ```
- 부분출력
  - ex) a b c d e f g h i j k l m n o p q r s t u v w x y z (head쪽 <---> tail쪽)
  - tail -n +6 만 지정하는 숫자가 조금 다름.
```
head -n 5 // 앞에서 5줄째까지. a b c d e 출력
head -n -5 // 앞에서 뒤에서 5개(v w x y z) 제외까지. a b c d e f g h i j k l m n o p q r s t u
tail -n +6 // 뒤에서 앞에서 5개(a b c d e) 제외까지. f g h i j k l m n o p q r s t u v w x y z, 
tail -n 5 // 뒤에서 5줄째까지. v w x y z
```

## awk
- 파일을 레코드 단위로 읽어 들여서 조건에 맞는 것 출력
- [참고자료(https://recipes4dev.tistory.com/171#32-%ED%95%84%EB%93%9C-%EA%B0%92-%EC%B6%9C%EB%A0%A5)